// Code generated by go-swagger; DO NOT EDIT.

package safe_api

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserOperationWithSafeOperationResponse user operation with safe operation response
//
// swagger:model UserOperationWithSafeOperationResponse
type UserOperationWithSafeOperationResponse struct {

	// Call data
	// Required: true
	CallData *string `json:"callData"`

	// Call gas limit
	// Required: true
	// Minimum: 0
	CallGasLimit *int64 `json:"callGasLimit"`

	// Entry point
	// Required: true
	EntryPoint *string `json:"entryPoint"`

	// Ethereum tx hash
	// Required: true
	EthereumTxHash *string `json:"ethereumTxHash"`

	// Init code
	// Required: true
	InitCode *string `json:"initCode"`

	// Max fee per gas
	// Required: true
	// Minimum: 0
	MaxFeePerGas *int64 `json:"maxFeePerGas"`

	// Max priority fee per gas
	// Required: true
	// Minimum: 0
	MaxPriorityFeePerGas *int64 `json:"maxPriorityFeePerGas"`

	// Nonce
	// Required: true
	// Minimum: 0
	Nonce *int64 `json:"nonce"`

	// Paymaster
	// Required: true
	Paymaster *string `json:"paymaster"`

	// Paymaster data
	// Required: true
	PaymasterData *string `json:"paymasterData"`

	// Pre verification gas
	// Required: true
	// Minimum: 0
	PreVerificationGas *int64 `json:"preVerificationGas"`

	// safe operation
	SafeOperation *SafeOperationResponse `json:"safeOperation,omitempty"`

	// Sender
	// Required: true
	Sender *string `json:"sender"`

	// Signature
	// Required: true
	Signature *string `json:"signature"`

	// User operation hash
	// Required: true
	UserOperationHash *string `json:"userOperationHash"`

	// Verification gas limit
	// Required: true
	// Minimum: 0
	VerificationGasLimit *int64 `json:"verificationGasLimit"`
}

// Validate validates this user operation with safe operation response
func (m *UserOperationWithSafeOperationResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCallData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCallGasLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntryPoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEthereumTxHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxFeePerGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxPriorityFeePerGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNonce(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymaster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymasterData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreVerificationGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSafeOperation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSender(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserOperationHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerificationGasLimit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateCallData(formats strfmt.Registry) error {

	if err := validate.Required("callData", "body", m.CallData); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateCallGasLimit(formats strfmt.Registry) error {

	if err := validate.Required("callGasLimit", "body", m.CallGasLimit); err != nil {
		return err
	}

	if err := validate.MinimumInt("callGasLimit", "body", *m.CallGasLimit, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateEntryPoint(formats strfmt.Registry) error {

	if err := validate.Required("entryPoint", "body", m.EntryPoint); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateEthereumTxHash(formats strfmt.Registry) error {

	if err := validate.Required("ethereumTxHash", "body", m.EthereumTxHash); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateInitCode(formats strfmt.Registry) error {

	if err := validate.Required("initCode", "body", m.InitCode); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateMaxFeePerGas(formats strfmt.Registry) error {

	if err := validate.Required("maxFeePerGas", "body", m.MaxFeePerGas); err != nil {
		return err
	}

	if err := validate.MinimumInt("maxFeePerGas", "body", *m.MaxFeePerGas, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateMaxPriorityFeePerGas(formats strfmt.Registry) error {

	if err := validate.Required("maxPriorityFeePerGas", "body", m.MaxPriorityFeePerGas); err != nil {
		return err
	}

	if err := validate.MinimumInt("maxPriorityFeePerGas", "body", *m.MaxPriorityFeePerGas, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateNonce(formats strfmt.Registry) error {

	if err := validate.Required("nonce", "body", m.Nonce); err != nil {
		return err
	}

	if err := validate.MinimumInt("nonce", "body", *m.Nonce, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validatePaymaster(formats strfmt.Registry) error {

	if err := validate.Required("paymaster", "body", m.Paymaster); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validatePaymasterData(formats strfmt.Registry) error {

	if err := validate.Required("paymasterData", "body", m.PaymasterData); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validatePreVerificationGas(formats strfmt.Registry) error {

	if err := validate.Required("preVerificationGas", "body", m.PreVerificationGas); err != nil {
		return err
	}

	if err := validate.MinimumInt("preVerificationGas", "body", *m.PreVerificationGas, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateSafeOperation(formats strfmt.Registry) error {
	if swag.IsZero(m.SafeOperation) { // not required
		return nil
	}

	if m.SafeOperation != nil {
		if err := m.SafeOperation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("safeOperation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("safeOperation")
			}
			return err
		}
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateSender(formats strfmt.Registry) error {

	if err := validate.Required("sender", "body", m.Sender); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateSignature(formats strfmt.Registry) error {

	if err := validate.Required("signature", "body", m.Signature); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateUserOperationHash(formats strfmt.Registry) error {

	if err := validate.Required("userOperationHash", "body", m.UserOperationHash); err != nil {
		return err
	}

	return nil
}

func (m *UserOperationWithSafeOperationResponse) validateVerificationGasLimit(formats strfmt.Registry) error {

	if err := validate.Required("verificationGasLimit", "body", m.VerificationGasLimit); err != nil {
		return err
	}

	if err := validate.MinimumInt("verificationGasLimit", "body", *m.VerificationGasLimit, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this user operation with safe operation response based on the context it is used
func (m *UserOperationWithSafeOperationResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSafeOperation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserOperationWithSafeOperationResponse) contextValidateSafeOperation(ctx context.Context, formats strfmt.Registry) error {

	if m.SafeOperation != nil {

		if swag.IsZero(m.SafeOperation) { // not required
			return nil
		}

		if err := m.SafeOperation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("safeOperation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("safeOperation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserOperationWithSafeOperationResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserOperationWithSafeOperationResponse) UnmarshalBinary(b []byte) error {
	var res UserOperationWithSafeOperationResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
